import { OperationObject, PathsObject } from "types.js";
import * as fs from "fs";
import * as path from "path";

export type RouteNode = {
  fns: Record<string, string>;
  children?: Record<string, RouteNode>;
};

const WARNING = `/**
* This file was auto-generated by openapi-typescript.
* Do not make direct changes to the file.
*/`;

const removeInvalidCharacters = (input: string): string => input.replace(/[^a-zA-Z0-9_]/g, "");

export function convertRoutes(input: PathsObject): RouteNode {
  const output: RouteNode = { fns: {}, children: {} };

  for (const [path, methods] of Object.entries(input)) {
    const childPaths = path.startsWith("/") ? path.slice(1).split("/") : path.split("/");

    let currentNode = output;
    for (const childPath of childPaths) {
      currentNode.children = currentNode.children || {};
      currentNode.children[childPath] = currentNode.children[childPath] || { fns: {} };
      currentNode = currentNode.children[childPath];
    }
    const res: Record<string, string> = {};
    for (const [key, val] of Object.entries(methods as Record<string, OperationObject>)) {
      if (typeof val === "object" && val !== null) {
        res[key] = val.operationId! as string;
      }
    }
    currentNode.fns = res;
  }

  return output;
}

export function createFilesFromRoutes(
  routes: RouteNode, // The list of routes to install for this module.
  basePath: string, // The base path to perform absolute imports from.
  schemaPathMapping: string // The path mapping to use when referencing the contract schema location.
) {
  return _createFilesFromRoutes("/", routes, basePath, schemaPathMapping, "");
}

function _createFilesFromRoutes(
  routerKey: string,
  routes: RouteNode, // The routes (and nested routes) to install for this module.
  installPath: string, // Where in the filesystem to install this module.
  schemaPathMapping: string, // The path mapping to use when referencing the contract schema location.
  relativePath: string
) {
  console.log("Processing route:", routerKey);
  console.log("Routes:", routes);
  ensureDirectoryExistence(installPath);
  const handlers = Object.entries(routes.fns).map(([methodKey, val]) => {
    return {
      method: methodKey,
      name: val,
      path: routerKey,
    };
  });
  writeRouterFile(
    installPath + "/" + "generated.router.ts",
    routes?.children ? Object.keys(routes?.children) : [],
    handlers,
    schemaPathMapping,
    relativePath
  );

  if (routes.children) {
    for (const [childKey, childRouteNode] of Object.entries(routes.children)) {
      _createFilesFromRoutes(
        childKey,
        childRouteNode,
        installPath + "/" + childKey,
        schemaPathMapping,
        relativePath + "/" + childKey
      );
    }
  }
}

function writeRouterFile(
  filepath: string,
  routers: string[],
  handlers: Handler[],
  schemaPathMapping: string,
  relpath: string
) {
  const output = [];
  output.push(WARNING);
  output.push('import promiseRouter from "express-promise-router";');
  output.push(`import { handlers } from "${schemaPathMapping}";`);
  for (const router of routers) {
    const routername = removeInvalidCharacters(router) + "Router";
    output.push(`import ${routername} from "./${router}/generated.router"`);
  }
  for (const handler of handlers) {
    output.push(`import ${handler.name} from "./${handler.name}";`);
  }
  output.push("");
  output.push("const router = promiseRouter();");

  output.push("");
  for (const handler of handlers) {
    output.push(
      `const ${handler.name}TypedHandler: handlers<{}, {}>["${handler.path}"]["${handler.method}"] = ${handler.name};`
    );
  }

  output.push("");
  for (const handler of handlers) {
    output.push(`router.${handler.method}("${handler.path}", ${handler.name}TypedHandler);`);
  }
  for (const router of routers) {
    const routername = removeInvalidCharacters(router) + "Router";
    output.push(`router.use("${router}", ${routername});`);
  }
  output.push("");
  output.push("export default router;");
  fs.writeFileSync(filepath, output.join("\n"));
}

function ensureDirectoryExistence(directory: string) {
  console.log("Ensuring", directory, "exists");
  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, { recursive: true });
  }
}

type Handler = {
  method: string;
  name: string;
  path: string;
};

const makeContractImportPath = (relpath: string) => {
  return (
    relpath
      .split("/")
      .map(() => "..")
      .join("/") + "/contract"
  );
};
